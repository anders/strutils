package main

import (
	"bufio"
	"bytes"
	"compress/zlib"
	"encoding/base64"
	"encoding/gob"
	"fmt"
	"go/format"
	"io"
	"io/ioutil"
	"log"
	"os"
	"strconv"
	"strings"
)

func parseBlocks(r io.Reader, buf *bytes.Buffer) error {
	buf.WriteString("var unicodeBlocks = []unicodeBlock{\n")
	scanner := bufio.NewScanner(r)
	scanner.Split(bufio.ScanLines)

	for scanner.Scan() {
		line := scanner.Text()

		// 0100..017F; Latin Extended-A
		idx := strings.IndexByte(line, ';')
		if idx < 1 {
			continue
		}

		if line[0] == '#' {
			continue
		}

		hexRange := line[0:idx]
		name := line[idx+2:]

		// look for ".."
		idx = strings.IndexByte(hexRange, '.')
		if idx < 0 {
			continue
		}

		fromHex := hexRange[0:idx]
		toHex := hexRange[idx+2:]

		from, err := strconv.ParseInt(fromHex, 16, 32)
		if err != nil {
			return fmt.Errorf("failed to parse hex(1): %w", err)
		}

		to, err := strconv.ParseInt(toHex, 16, 32)
		if err != nil {
			return fmt.Errorf("failed to parse hex(2): %w", err)
		}

		buf.WriteString(fmt.Sprintf("{0x%x, 0x%x, %#v},\n", from, to, name))
	}

	buf.WriteString("}\n")
	return nil
}

type dataRow struct {
	R       rune
	Name    string
	OldName string
}

func loadUnicodeData(r io.Reader) ([]dataRow, error) {
	ret := []dataRow{}
	sc := bufio.NewScanner(r)
	sc.Split(bufio.ScanLines)
	for sc.Scan() {
		tmp := strings.Split(sc.Text(), ";")
		r, err := strconv.ParseInt(tmp[0], 16, 32)
		if err != nil {
			return ret, err
		}
		ret = append(ret, dataRow{rune(r), tmp[1], tmp[10]})
	}
	return ret, nil
}

func main() {
	buf := &bytes.Buffer{}
	buf.WriteString("// generated by unicodegen\n")
	buf.WriteString("package strutils\n")

	f, err := os.Open("Blocks.txt")
	if err != nil {
		log.Fatalf("error opening Blocks.txt: %w", err)
	}
	defer f.Close()

	if err := parseBlocks(f, buf); err != nil {
		log.Fatal(err)
	}

	f, err = os.Open("UnicodeData.txt")
	if err != nil {
		log.Fatal(err)
	}
	defer f.Close()

	chs, err := loadUnicodeData(f)
	if err != nil {
		log.Fatal(err)
	}

	chb := &bytes.Buffer{}
	enc := gob.NewEncoder(chb)
	if err := enc.Encode(chs); err!= nil {
		log.Fatal(err)
	}

	chc := &bytes.Buffer{}

	w := zlib.NewWriter(chc)
	if _, err := w.Write(chb.Bytes()); err != nil {
		log.Fatal(err)
	}
	if err := w.Flush(); err != nil {
		log.Fatal(err)
	}

	s := base64.StdEncoding.EncodeToString(chc.Bytes())
	buf.WriteString("var gobbedUnicode =")

	rd := strings.NewReader(s)
	total := 0
	tmp := make([]byte, 120)
	for {
		n, err := rd.Read(tmp)
		if err == io.EOF { break }
		total += n
		buf.WriteByte('"')
		buf.Write(tmp[0:n])
		if total < len(s) {
			buf.WriteString("\" +\n")
		} else {
			buf.WriteString("\"")
		}
	}

	// gofmt
	src, err := format.Source(buf.Bytes())
	if err != nil {
		log.Fatal(err)
	}

	if err := ioutil.WriteFile("unicodedata_gen.go", src, 0644); err != nil {
		log.Fatal(err)
	}
}
